<main><div class="container">
  <section>
    <p class="large">
      Griddler is a Rails engine that provides an endpoint for
      <a href="http://sendgrid.com/docs/API%20Reference/Webhooks/parse.html">SendGrid</a>,
      <a href="http://cloudmailin.com">Cloudmailin</a>,
      <a href="http://developer.postmarkapp.com/developer-inbound-parse.html">Postmark</a> or
      <a href="http://help.mandrill.com/entries/21699367-Inbound-Email-Processing-Overview">Mandrill</a>
      and hands off the email to your application.
    </p>
  </section>

  <section class="code">
<h2>Tutorials</h2>

<ul>
<li>SendGrid wrote a
<a href="https://sendgrid.com/blog/receiving-email-in-your-rails-app-with-griddler/">great tutorial</a>
on integrating Griddler with your application.</li>
<li>We have our own blog post on the subject over at
<a href="http://robots.thoughtbot.com/post/42286882447/handle-incoming-email-with-griddler">Giant Robots</a>.</li>
</ul><h2>Installation</h2>

<p>Add griddler to your application's Gemfile and then run <code>bundle install</code>:</p>

{% highlight ruby %}
gem 'griddler'
{% endhighlight %}

<p>Griddler comes with a default endpoint that will be displayed at the bottom
of the output of <code>rake routes</code>. If there is a previously defined route that
matches <code>/email_processor</code> &mdash; or you would like to rename the
matched path &mdash; you may add the route to the desired position in routes.rb
with the following:</p>

{% highlight ruby %}
post '/email_processor' => 'griddler/emails#create'
{% endhighlight %}

<h2>Defaults</h2>

<p>By default Griddler will look for a class named <code>EmailProcessor</code>
which you create. It will initialize that class with a
<code>Griddler::Email</code> instance representing the incoming email, then call
the <code>process</code> instance method on that class. The <code>process</code>
should handle processing the incoming email. For example, in
<code>./lib/email_processor.rb</code>:</p>

{% highlight ruby %}
class EmailProcessor
  def initialize(email)
    @email = email
  end

  def process
    # all of your application-specific code here - creating models,
    # processing reports, etc

    # Here's an example of model creation
    user = User.find_by_email(@email.from[:email])
    user.posts.create!(
      subject: @email.subject,
      body: @email.body
    )
  end
end
{% endhighlight %}

<p>The <code>email</code> object passed into your initialize method is a
<code>Griddler::Email</code> instance that responds to:</p>

<ul>
<li><code>.to</code></li>
<li><code>.from</code></li>
<li><code>.subject</code></li>
<li><code>.body</code></li>
<li><code>.raw_text</code></li>
<li><code>.raw_html</code></li>
<li><code>.raw_body</code></li>
<li><code>.attachments</code></li>
<li><code>.headers</code></li>
<li><code>.raw_headers</code></li>
</ul><p>Each of those has some sensible defaults.</p>

<p><code>.from</code>, <code>.raw_body</code>, <code>.raw_headers</code>, and <code>.subject</code> will contain the obvious
values found in the email, the raw values from those fields.</p>

<p><code>.body</code> will contain the full contents of the email body <strong>unless</strong> there is a
line in the email containing the string <code>-- Reply ABOVE THIS LINE --</code>. In that
case <code>.body</code> will contain everything before that line.</p>

<p><code>.to</code> will contain all of the text before the email's "@" character. We've found
that this is the most often used portion of the email address and consider it to
be the token we'll key off of for interaction with our application.</p>

<p><code>.attachments</code> will contain an array of attachments as multipart/form-data files
which can be passed off to attachment libraries like Carrierwave or Paperclip.</p>

<p><code>.headers</code> will contain a hash of header names and values as parsed by the Mail
gem. Headers will only be parsed if the adapter supports a headers option.</p>

<h2>Configuration Options</h2>

<p>An initializer can be created to control some of the options in Griddler. Defaults
are shown below with sample overrides following. In <code>config/initializer/griddler.rb</code>:</p>

{% highlight ruby %}
Griddler.configure do |config|
  config.processor_class = EmailProcessor # MyEmailProcessor
  config.processor_method = :process # The `process` part of MyEmailProcessor.new(email).process
  config.reply_delimiter = '-- REPLY ABOVE THIS LINE --'
  config.email_service = :sendgrid
end
{% endhighlight %}

<ul>
<li><code>config.processor_class</code> is the class Griddler will use to handle your incoming emails.</li>
<li><code>config.processor_method</code> is the method Griddler will call on the processor class when handling your incoming emails.</li>
<li><code>config.reply_delimiter</code> is the string searched for that will split your body.</li>
<li><code>config.email_service</code> tells Griddler which email service you are using. The supported
email service options are <code>:sendgrid</code> (the default), <code>:cloudmailin</code> (expects
multipart format), <code>:postmark</code> and <code>:mandrill</code>.</li>
</ul>

<h2>Testing In Your App</h2>

<p>You may want to create a factory for when testing the integration of Griddler into
your application. If you're using factory_girl this can be accomplished with the
following sample factory.</p>

{% highlight ruby %}
factory :email, class: OpenStruct do
  # Assumes Griddler.configure.to is :hash (default)
  to [{ raw: 'to_user@email.com', email: 'to_user@email.com', token: 'to_user', host: 'email.com' }]
  from 'user@email.com'
  subject 'email subject'
  body 'Hello!'
  attachments {[]}

  trait :with_attachment do
    attachments {[
      ActionDispatch::Http::UploadedFile.new({
        filename: 'img.png',
        type: 'image/png',
        tempfile: File.new("#{File.expand_path File.dirname(__FILE__)}/fixtures/img.png")
      })
    ]}
  end
end
{% endhighlight %}

<p>Bear in mind, if you plan on using the <code>:with_attachment</code> trait, that this
example assumes your factories are in <code>spec/factories.rb</code> and you have
an image file in <code>spec/fixtures/</code>.</p>

<p>To use it in your test(s) just build with <code>email = build(:email)</code>
or <code>email = build(:email, :with_attachment)</code>.</p>

<h2>Adapters</h2>

<p><code>Griddler::Email</code> expects certain parameters to be in place for proper parsing
to occur. When writing an adapter, ensure that the <code>normalized_params</code> method
of your adapter returns a hash with these keys:</p>

<ul>
<li>
<code>:to</code> The recipient field</li>
<li>
<code>:from</code> The sender field</li>
<li>
<code>:subject</code> Email subject</li>
<li>
<code>:text</code> The text body of the email</li>
<li>
<code>:html</code> The html body of the email, nil or empty string if not present</li>
<li>
<code>:attachments</code> (can be an empty array) Array of attachments to the email</li>
<li>
<code>:headers</code> (optional) The raw headers of the email</li>
<li>
<code>:charsets</code> (optional) A JSON string containing the character sets of the
fields extracted from the message</li>
</ul><h2>Upgrading to Griddler 0.5.0</h2>

<p>Because of an issue with the way Griddler handled recipients in the <code>To</code> header,
a breaking change was introduced in Griddler 0.5.0 that requires a minor change
to <code>EmailProcessor</code> or <code>processor_class</code>.</p>

<p>Previously, a single address was returned from <code>Griddler::Email#to</code>. Moving
forward, this field will always be an array. Generally speaking, you will want
to do something like this to handle the change:</p>

{% highlight ruby %}
# before
def initialize(email)
  @to = email.to
  @from = email.from
  @body = email.body
end

# after
def initialize(email)
  @to = pick_meaningful_recipient(email.to)
  @from = email.from
  @body = email.body
end

private

def pick_meaningful_recipient(recipients)
  recipients.find { |address| address =~ /@mydomain.com$/ }
end
{% endhighlight %}

<h2>Using Griddler with Mandrill</h2>

<p>When adding a webhook in their administration panel, Mandrill will issue a HEAD
request to check if the webhook is valid (see
<a href="http://help.mandrill.com/entries/21699367-Inbound-Email-Processing-Overview">Adding Routes</a>).
If the HEAD request fails, Mandrill will not allow you to add the webhook.
Since Griddler is only configured to handle POST requests, you will not be able
to add the webhook as-is. To solve this, add a temporary route to your
application that can handle the HEAD request:</p>

{% highlight ruby %}
# routes.rb
get '/email_processor', :to => proc { [200, {}, ["OK"]] }
{% endhighlight %}

<p>Once you have correctly configured Mandrill, you can go ahead and delete this code.</p>

<h2>More Information</h2>

<ul>
<li><a href="http://www.sendgrid.com">SendGrid</a></li>
<li><a href="http://www.sendgrid.com/docs/API%20Reference/Webhooks/parse.html">SendGrid Parse API</a></li>
<li><a href="http://cloudmailin.com">Cloudmailin</a></li>
<li><a href="http://docs.cloudmailin.com/">Cloudmailin Docs</a></li>
<li><a href="http://postmarkapp.com">Postmark</a></li>
<li><a href="http://developer.postmarkapp.com/">Postmark Docs</a></li>
<li><a href="http://mandrill.com">Mandrill</a></li>
<li><a href="http://help.mandrill.com/forums/21092258-Inbound-Email-Processing">Mandrill Docs</a></li>
</ul><h2>Credits</h2>

<p>Griddler was written by Caleb Thompson and Joel Oliveira. It is maintained by
Gabe Berke-Williams.</p>

<p>Large portions of the codebase were extracted from thoughtbot's
<a href="http://www.apptrajectory.com">Trajectory</a>.</p>

<p><img src="http://thoughtbot.com/images/tm/logo.png" alt="thoughtbot"></p>

<p>The names and logos for thoughtbot are trademarks of thoughtbot, inc.</p>

</section>
</div></main>
